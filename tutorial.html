<h1>Balancing Concurrent Overhead With Parallel Performance</h1>

{{removeAll .SiteDir}}
{{mkdirAll .SiteDir}}
{{removeAll .BuildDir}}
{{mkdirAll .BuildDir}}
{{cd .BuildDir}}
{{runNoOutput "git" "init"}}

<blockquote>
<p>WTH? Shouldnâ€™t this be faster? - <a href="https://forum.golangbridge.org/t/concurrency-slower/5002" title="Concurrency slower?">Concurrency slower?</a></p>
</blockquote>

<p>This started as a simple exercise to learn concurrency in Go. The exercise had a simple premise:
	<ul>
		<li>create a list of 1,000,000 lotto numbers</li>
		<li>a lotto number is a list of 7 random integers</li>
	</ul>
</p>

<p>But instead of fast running goodness, it ended slower than it started:
	<blockquote>
	<ul>
		<li>Initially on my system it took 8.5 s (i7)</li>
		<li>Giving the channel such a large buffer reduces the used time to ~4.5 s</li>
		<li><code>make</code>ing the array list with the final size increases the used time by ~20%</li>
		<li>Running as a go routine increases the used time to ~13 s - WTH? Shouldn&#39;t this be faster?</li>
	</ul>
	</blockquote>
</p>

<p>Go's concurrency primitives are light-weight. However, they are not free. Since there is a cost, there needs to be a return on that investment. For this exercise, the expected return is a faster runtime. Balancing the costs and the benefits is the real trick.</p>

<!-- <p>Follow along as I show one method, and the tools used, to balance the execution costs of concurrency with the benefits of reduced runtime through a parallel implementation.</p> -->

<!-- <p>NOTE: The process I describe is not the actual process I followed. It does the describe all the failed attempts I actually made. That would be extremely tedious to read (and even more so to write). However, the process shown <em>does</em> include the methods that indicate the step was productive</p> -->

<h2>The Posted Code</h2>
{{apply "original"}}
{{commit "original"}}

<p>Let's start with what was posted:</p>

{{file "main.go"}}

<p>This code has some good things going for it:
	<ul>
		<li>Easy to try out improvements because timing checks are built in.</li>
		<li>Visual test, <code>len(list)</code>, indicates if the program worked or not</li>
	</ul>
</p>

<p>However, it also has some problems as can be shown by running it:</p>

{{run "go" "run" "main.go"}}

<p>Notice that <code>len(list)</code> is not the expected 1,000,000. <a href="https://forum.golangbridge.org/t/concurrency-slower/5002/3?u=nathankerr">Another posted version</a> had the expected <code>len(list)</code>, but only one of the elements was set (1M times).</p>

<p>Let's use Go's built-in testing and benchmarking tools to improve the code.</p>

<h2>Extract to Function</h2>
{{apply "extract-function"}}
{{commit "extract function"}}

<p>The first step is to isolate the code to be tested and benchmarked. This was done by first extracting the relevant parts from <code>main</code> into a new function <code>lottoNumbers(int) [][]int</code> that takes the number of lotto numbers to generate as its argument and returns the list of lotto numbers.</p>

<p>Global variables make testing and benchmarking difficult because it is hard to make sure that all the globals were reset or useable for a second run. So I made <code>list</code> local to <code>lottoNumbers</code>.</p>

<p>The last thing to do is make the number of lotto numbers to generate tunable. This was already partially done by making it an argument to <code>lottoNumbers()</code>, however adding a global constant, <code>numberToGenerate</code> that will only be referred to in <code>main</code> and the tests and benchmarks allows that value to be easily changed without leaving hard-to-spot values that only differ by a 0, such as 10000000 and
1000000 in the posted code.</p>

<p>This leaves us with:</p>

{{file "main.go"}}

<p>A quick run shows that refactoring did not break the code:</p>

{{run "go run main.go"}}

<h2>Testing with <code>go test</code></h2>
{{apply "testing"}}
{{commit "testing"}}

<p>Now that the code is in a testable state, its time to write some tests. Testing results based on random numbers is really hard. The test suite for <a href="https://golang.org/pkg/math/rand"><code>math/rand</code></a>, for example, includes a statistical analysis of the generated numbers.</p>

<p>Since there are already two failure cases: not enough numbers, and most numbers not being set, at least these cases need to be tested for. The first case is easy while the second is harder.</p>

<p>Since this testing is done as an exercise, and I don't really know what the properties of lottery numbers should be, I relied on the existing code to figure out what should be tested and came up with the following criteria:
	<ul>
		<li>the correct number of lotto numbers was generated</li>
		<li>the maximum number in a lotto number is 48</li>
		<li>the minimum number in a lotto number is 0</li>
		<li>lotto numbers have length 7</li>
		<li>the numbers in the lotto numbers have a <a href="https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29">uniform distribution</a></li>
	</ul>
</p>

<p>I picked a few attributes of distributions to compare against expected values:
<ul>
	<li><a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Skewness">Skewness</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Excess_kurtosis">Ex. kurtosis</a></li>
</ul>
</p>

<p>I used <a href="https://godoc.org/github.com/gonum/stat">github.com/gonum/stat</a> to handle the statistics and ended up with the following test:</p>

{{file "main_test.go"}}

{{run "go" "test"}}

<p>Since this version of <code>lottoNumbers</code> only fails by not generating enough numbers, I replaced it with the other posted version to show the other tests also work.</p>

{{apply "other-version"}}
{{commit "other-version"}}

{{file "main.go"}}

{{run "go test"}}

<h2>A Serial Version</h2>
{{apply "serial"}}
{{commit "serial"}}

<p>A general rule of thumb is: make it <em>work</em> fast, then make it work <em>fast</em>. Since the existing versions don't work, as shown by the failing tests, the first thing to do is get a version that consistently passes the tests. Since the concurrency used here complicates the design instead of simplifying it, a purely serial version that is correct is a better starting point. I tried to reproduce the serial version the poster started with.</p>

{{file "main.go"}}

{{run "go" "run" "main.go"}}

{{run "go" "test" "-count 5"}}

<p>This version is much faster. The speedup was achieved by not doing the extra work the original version did. Also, the tests passed 5 times..</p>

<h2>Benchmarks</h2>
{{apply "benchmark"}}

<p>Go benchmarks are quick to get started with: loop `b.N` times, calling the function to be benchmarked each iteration.</p>

{{file "main_test.go"}}

<p>Benchmarks are ran with <code>go test</code>.</p>

{{run "go test -bench=. -benchmem -count 5 | tee serial.txt"}}

<p>The output shows the benchmark, the number of times the benchmark loop ran (i.e., <code>b.N</code>), and the average time for each run (i.e., total_time/b.N)</p>

<p>NOTE: go will run the entire test suite before running the benchmarks. This is helpful to ensure the whatever you are benchmarking still passes the tests.</p>

{{commit "benchmark"}}

<h2>Parallel</h2>
{{apply "parallel"}}

{{file "main.go"}}

{{run "go test -bench=. -count 5 | tee parallel.txt"}}

{{benchstat "serial.txt parallel.txt"}}

{{commit "parallel"}}

<h2>Finding Blocking Operations</h2>

{{run "go test -blockprofile block.pprof"}}
{{run "go tool pprof -list=lottoNumbers ./concurrency-slower.test block.pprof"}}

{{commit "blocking-operations"}}

<h2>Non-Blocking Rand</h2>
{{apply "non-blocking-rand"}}

{{file "main.go"}}

{{run "go test -bench=. -count 5 | tee non-blocking-rand.txt"}}

{{benchstat "serial.txt non-blocking-rand.txt"}}

{{commit "non-blocking-rand"}}

<h2>Reducing allocations</h2>

{{run "go test -bench=. -count 5 -benchmem| tee non-blocking-rand-mem.txt"}}

{{apply "reduce-allocs"}}

{{run "go test -bench=. -count 5 -benchmem| tee reduce-allocs.txt"}}

{{benchstat "non-blocking-rand-mem.txt reduce-allocs.txt"}}

{{commit "reduce allocs"}}

<h2>Success</h2>

{{benchstat "serial.txt reduce-allocs.txt"}}

<hr>
<pre>TODO
- msu
- figure out how to sanitize pprof output
- file should only display the file, diffs are hard to format and I want to avoid that for now. Also the automatic switching won't let me show the whole thing when the diff is complicated.
- title

published repo:
- source branch for tutorial source
- 2017-04-2x branch for released version
- set dated branch as default branch
- readme in all branches explaining the organization

share:
- I used go's testing, benchmarking, and blockprofile tools to show an alternate way to make the same progress. link
</pre>
