{{version}}
<h1>Concurrency Slower?</h1>

{{removeAll .SiteDir}}
{{mkdirAll .SiteDir}}
{{removeAll .BuildDir}}
{{mkdirAll .BuildDir}}
{{cd .BuildDir}}
{{runNoOutput "git" "init"}}
{{runNoOutput "git checkout -b" (.Now.Format "2006-01-02")}}
{{copy "build-gitignore" .BuildDir ".gitignore"}}
{{copy "build-readme.md" .BuildDir "readme.md"}}
{{commit "initial"}}

<blockquote>
WTH? Shouldn’t this be faster? - <a href="https://forum.golangbridge.org/t/concurrency-slower/5002" title="Concurrency slower?">Concurrency slower?</a>
</blockquote>

<p>This started as a simple exercise to learn concurrency in Go. The exercise had a simple premise:
	<ul>
		<li>create a list of 1,000,000 lotto numbers</li>
		<li>a lotto number is a list of 7 random integers</li>
	</ul>
</p>

<p>But instead of fast running goodness, it ended slower than it started:
	<blockquote>
	<ul>
		<li>Initially on my system it took 8.5 s (i7)</li>
		<li>Giving the channel such a large buffer reduces the used time to ~4.5 s</li>
		<li><code>make</code>ing the array list with the final size increases the used time by ~20%</li>
		<li>Running as a go routine increases the used time to ~13 s - WTH? Shouldn&#39;t this be faster?</li>
	</ul>
	</blockquote>
</p>

<p>Go's concurrency primitives are light-weight. However, they are not free. Since there is a cost, there needs to be a return on that investment. For this exercise, the expected return is a faster runtime. Balancing the costs and the benefits is the real trick.</p>

<!-- <p>Follow along as I show one method, and the tools used, to balance the execution costs of concurrency with the benefits of reduced runtime through a parallel implementation.</p> -->

<!-- <p>NOTE: The process I describe is not the actual process I followed. It does the describe all the failed attempts I actually made. That would be extremely tedious to read (and even more so to write). However, the process shown <em>does</em> include the methods that indicate the step was productive</p> -->

<p>The code and associated files for this tutorial can be gotten with:
<pre>go get -d pocketgophers.com/concurrency-slower</pre>
Each commit in the downloaded git repository corresponds with the progress made in this tutorial.
</p>

<p>This tutorial was ran on a Late 2010 MacBook Air with 1.6GHz Intel Core 2 Duo with 4GB RAM running macOS 10.12.4.</p>


<h2>The Posted Code</h2>
{{apply "original"}}
{{commit "original"}}

<p>Let's start with what was posted:</p>

{{file "main.go"}}

<p>This code has some good things going for it:
	<ul>
		<li>Easy to try out improvements because timing checks are built in.</li>
		<li>Visual test, <code>len(list)</code>, indicates if the program worked or not</li>
	</ul>
</p>

<p>However, it also has some problems as can be shown by running it:</p>

{{run "go" "run" "main.go"}}

<p>Notice that <code>len(list)</code> is not the expected 1,000,000. <a href="https://forum.golangbridge.org/t/concurrency-slower/5002/3?u=nathankerr">Another posted version</a> had the expected <code>len(list)</code>, but only one of the elements was set (1M times).</p>

<p>Let's use Go's built-in testing and benchmarking tools to improve the code.</p>

<h2>Extract to Function</h2>
{{apply "extract-function"}}
{{commit "extract function"}}

<p>The first step is to isolate the code to be tested and benchmarked. This was done by first extracting the relevant parts from <code>main</code> into a new function <code>lottoNumbers(int) [][]int</code> that takes the number of lotto numbers to generate as its argument and returns the list of lotto numbers.</p>

<p>Global variables make testing and benchmarking difficult because it is hard to make sure that all the globals were reset or useable for a second run. So I made <code>list</code> local to <code>lottoNumbers</code>.</p>

<p>The last thing to do is make the number of lotto numbers to generate tunable. This was already partially done by making it an argument to <code>lottoNumbers()</code>, however adding a global constant, <code>numberToGenerate</code> that will only be referred to in <code>main</code> and the tests and benchmarks allows that value to be easily changed without leaving hard-to-spot values that only differ by a 0, such as 10000000 and
1000000 in the posted code.</p>

<p>This leaves us with:</p>

{{file "main.go"}}

<p>A quick run shows the code works as it did before:</p>

{{run "go run main.go"}}

<h2>Testing with <code>go test</code></h2>
{{apply "testing"}}
{{commit "testing"}}

<p>Now that the code is in a testable state, its time to write some tests. Testing results based on random numbers is really hard. The test suite for <a href="https://golang.org/pkg/math/rand"><code>math/rand</code></a>, for example, includes a statistical analysis of the generated numbers.</p>

<p>Since there are already two failure cases: not enough numbers, and most numbers not being set, at least these cases need to be tested for. The first case is easy while the second is harder.</p>

<p>Since this testing is done as an exercise, and I don't really know what the properties of lottery numbers should be, I relied on the existing code to figure out what should be tested and came up with the following criteria:
	<ul>
		<li>the correct number of lotto numbers was generated</li>
		<li>the maximum number in a lotto number is 48</li>
		<li>the minimum number in a lotto number is 0</li>
		<li>lotto numbers have length 7</li>
		<li>the numbers in the lotto numbers have a <a href="https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29">uniform distribution</a></li>
	</ul>
</p>

<p>I picked a few attributes of distributions to compare against expected values:
<ul>
	<li><a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Skewness">Skewness</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Excess_kurtosis">Ex. kurtosis</a></li>
</ul>
</p>

<p>I used <a href="https://godoc.org/github.com/gonum/stat">github.com/gonum/stat</a> to handle the statistics and ended up with the following test:</p>

{{file "main_test.go"}}

{{run "go" "test"}}

<p>Since this version of <code>lottoNumbers</code> only fails by not generating enough numbers, I replaced it with the other posted version to show the other tests also work.</p>

{{apply "other-version"}}
{{commit "other-version"}}

{{file "main.go"}}

{{run "go run main.go"}}

{{run "go test"}}

<h2>A Serial Version</h2>
{{apply "serial"}}
{{commit "serial"}}

<p>A general rule of thumb is: make it <em>work</em> fast, then make it work <em>fast</em>. Since the existing versions don't work, as shown by the failing tests, the first thing to do is get a version that consistently passes the tests. Since the concurrency used here complicates the design instead of simplifying it, a purely serial version that is correct is a better starting point. I tried to reproduce the serial version the poster started with.</p>

{{file "main.go"}}

{{run "go" "run" "main.go"}}

{{run "go" "test"}}

<p>This version is much faster. The speedup was achieved by not doing the extra work the original version did. Also, the tests passed 5 times..</p>

<h2>Benchmarks</h2>
{{apply "benchmark"}}

<p>Now that we have a working version, its time to make it work <em>fast</em>. Benchmarks are a useful tool to do so. Go benchmarks are quick to get started with: loop <code>b.N</code> times, calling the function to be benchmarked each iteration.</p>

{{file "main_test.go"}}

<p>Benchmarks are ran with <code>go test</code>. I save the output using <a href="https://en.wikipedia.org/wiki/Tee_(command)"><code>tee</code></a> for later comparison.</p>

{{run "go test -bench=. -benchmem -count 10 | tee serial.txt"}}

<p>The output shows the benchmark, the number of times the benchmark loop ran (i.e., <code>b.N</code>), the average time for each run (i.e., <code>total_time/b.N</code>), the average bytes allocated each run, and the average number of allocatons for each run.</p>

<p>Go will run the test suite before running the benchmarks. This is helpful to ensure the whatever you are benchmarking still passes the tests. The benchmark (and tests) are run 5 times to create enough data for later statistical analysis.</p>

{{commit "benchmark"}}

<h2>A Parallel Version</h2>
{{apply "parallel"}}

<p>When parallelizing code I like to start by finding the minimal unit of work. This is the smallest unit of work the parallel version needs to do. In this case the minimal unit is:

<pre><code>list = append(list, []int{
	rand.Intn(49),
	rand.Intn(49),
	rand.Intn(49),
	rand.Intn(49),
	rand.Intn(49),
	rand.Intn(49),
	rand.Intn(49),
})</code></pre>
</p>

<p>If the minimal scalable unit were safe for concurrent operation (this one is not), running each one in a separate goroutine maximizes concurrency. Even though go can run a million goroutines, there is cost associated with launching and scheduling them. Any interaction between goroutines through channels or mutexes also introduces work the serial version did not need to do. All this extra work is overhead.</p>

<p>The trick to minimizing overhead to gain the benefits of parallelization is to find the minimal scalable unit. By scalable, I mean that the amount of work done by each goroutine is adjustable. In this case the minimal scalable unit is:
<pre><code>for i := 0; i < n; i++ {
	list = append(list, []int{
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
	})
}</code></pre>
Instead of each goroutine generating one lotto number, they will generate <code>n</code> lotto numbers.
</p>

<p>The next step is to make the minimal scalable unit safe for concurrent execution. The main problem here is append. Since I learned to write code on distributed systems (i.e., many separate computers), my first instinct is to build up a local list and then send it to another goroutine that combines the lists together. While this method works, building local lists, sending them around, and combining them together is all extra work that does not need to be done because each goroutine can just change its part of the list. This can be checked as safe by using the race detector. That changes the minimal scalable unit to:
<pre><code>for i := begin; i < end; i++ {
	list[i] = []int{
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
		rand.Intn(49),
	}
}</code></pre>
Where <code>begin</code> and <code>end</code> are the part of the work to be accomplished by that unit.
</p>

<p>The work can then be split as evenly as possible between the desired number of goroutines. Since this example appears to be limited by CPU, one goroutine per processor maximizes the potential benefit (amount of CPU capacity) while minimizing overhead.</p>

<p>Using a <a href="https://godoc.org/sync#WaitGroup"><code>sync.WaitGroup</code></a> to wait until all the goroutines have completed, results in this parallel version:</p>

{{file "main.go"}}

<p>Running the test suite with the race detector enabled checks that this version produces correct results and data races were found.</p>

{{run "go test -race"}}

<p>Since the race detector reduces performance, I don't use it when benchmarking.</p>

{{run "go test -bench=. -count 10 | tee parallel.txt"}}

<p>To compare benchmark results and decide if the differences are significant (i.e., <code>p &lt;= 0.05</code>), I use <a href="https://godoc.org/golang.org/x/perf/cmd/benchstat">benchstat</a>.</p>

{{benchstat "serial.txt parallel.txt"}}

<p>Even with my efforts to minimize overhead, the parallel version is slower. Go provides some tools to help figure out what is happening.</p>

{{commit "parallel"}}

<h2>Reducing Blocking Operations</h2>

<p>Not all blocking operations are bad. For example, <code>wg.Wait</code> blocks until all the workers have completed their work. What we don't want are unnecessary blocking operations. The block profile helps find blocking operations:</p>

{{run "go test -blockprofile block.pprof"}}

{{run "go tool pprof -list=lottoNumbers ./concurrency-slower.test block.pprof"}}

<p>Here we see that <code>wg.Wait</code> blocks as expected (and needed). However, the blocks by <code>rand.Intn</code> are not needed and therefore reduce efficiency.</p>

<blockquote>The default Source is safe for concurrent use by multiple goroutines. - <a href="https://godoc.org/math/rand"><code>math/rand</code></a></blockquote>

<p>The default Source is made safe by locking. This means that only one random number can be generated at a time. The solution is to use a separate source for each worker. To do this correctly, a little understanding of random number generators (RNGs) is needed.</p>

<p>Imagine a function, <code>rand</code>, that takes a seed and returns and infinite slice of random values. For deterministic RNGs like <code>math/rand</code>'s, <code>rand(seed)[n] == rand(seed)[n]</code> is true for every integer <code>n</code>. This property is helpful in debugging and testing processes that depend on random number by making the RNG generate the same sequence of numbers each time.</p>

<p>This same property is not helpful when you want to make sure that different processes have different random numbers because many deterministic RNGs also have the property that <code>rand(seed)[n+1] == rand(seed+1)[n]</code> is true for every integer <code>n</code>. This property is helpful in that, with care, the same sequence of random numbers can be generated by many RNGs as from a single RNG. This would allow, for example, the list produced by the serial version of <code>lottoNumbers</code> to be directly compared to the list produced by a parallel version using separate generators.</p>

<p>However, the RNG implemented in <code>math/rand</code> “cooks” the seed first. The cooking process uses a list of random numbers embedded in the code (to keep the first property) to alter the seed before seeding the generator (i.e., <code>rand(cook(seed))</code>). While this makes generating different parts of the same sequence impractical, it makes getting different sequences easy. Instead of needing to know how many random numbers are to be used by each worker to avoid overlap (and therefore reduced randomness), the seeds only need to be different.</p>

<p>With this knowledge, I created a separate source for each worker, seeding them with the time and the number of the worker.</p>

{{apply "non-blocking-rand"}}

{{file "main.go"}}

{{run "go test -bench=. -benchmem -count 10 | tee non-blocking-rand.txt"}}

{{benchstat "serial.txt non-blocking-rand.txt"}}

<p>The benchmark shows the decreased run time we expected in the first place.</p>

{{commit "non-blocking-rand"}}

<h2>Reducing Allocations</h2>

<p>Another thing to notice is the 1.00M allocations per operation. Go allocates memory on the stack or the heap. Stack memory is managed at compile time. Heap memory, on the other hand, is managed at runtime. This includes deciding where on the heap to allocate the memory and garbage collection when that memory is no longer needed. It is because of this extra cost that <code>-benchmem</code> only lists heap allocations.</p>

<p>Go tries to keep everything on the stack, using escape analysis to figure out what must be on the heap. Compiling with <code>-gcflags=-m</code> displays the results of the escape analysis process:</p>

{{run "go build -gcflags=-m"}}

<p>As with blocking operations, some variables need to be on the heap. The goal is to find the things that escape and rewrite the code so it does not need to.</p>

<p>Since one million is the same number as the number of lotto number to generate, most of the allocations must happen on:
<pre><code>list[i] = []int{
	r.Intn(49),
	r.Intn(49),
	r.Intn(49),
	r.Intn(49),
	r.Intn(49),
	r.Intn(49),
	r.Intn(49),
}</code></pre>
The escape analysis confirms this with <code>[]int literal escapes to heap</code>.
</p>

<blockquote>A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment). - <a href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices: usage and internals</a></blockquote>

<p>Making a new slice also makes the underlying array. Since the slices are required, we can instead remove the allocation of the underlying arrays by preallocating enough space for all the random numbers we need and then slicing that array into the lotto numbers.</p>

{{apply "reduce-allocs-slices"}}
{{commit "reduce-allocs-slices"}}

{{file "main.go"}}

<p>The <code>[]int</code> literal no longer escapes to heap and, as a nice side benefit, the repetition of <code>r.Intn(49)</code> is removed.</p>

<p>The next thing to deal with is the <code>WaitGroup</code>. It needs to be on the heap because it is accessed from different goroutines. What doesn't need to be on the heap are the many references to it. This can be fixed by initially getting a pointer to it.</p>

{{apply "reduce-allocs-waitgroup"}}
{{commit "reduce-allocs-waitgroup"}}

<p>The function and <code>&amp;rand.Rand</code> literal escapes can be removed by moving the creation of <code>r</code> into the closer and then converting the closure into a separate function.</p>

{{apply "reduce-allocs-closure"}}
{{commit "reduce-allocs-closure"}}

{{file "main.go"}}

{{run "go build -gcflags=-m"}}

<p>The remaining escapes are required:
<dl>
	<dt><code>make([]int, total)</code></dt><dd><code>all</code>, accessed by concurrent <code>lottoNumberWorker</code>s</dd>
	<dt><code>make([][]int, n)</code></dt><dd><code>list</code>, accessed by calling function after return</dd>
	<dt><code>&amp;sync.WaitGroup literal</code></dt><dd><code>wg</code>, accessed by concurrent <code>lottoNumberWorker</code>s</dd>
</dl>
</p>

<p>Now to see the fruits of our labor</p>

{{run "go test -bench=. -count 10 -benchmem| tee reduce-allocs.txt"}}

{{benchstat "non-blocking-rand.txt reduce-allocs.txt"}}

{{commit "reduce allocs"}}

<h2>Success</h2>

<p>Since you've made it this far you have seen, or even tried yourself, the following concepts and tools:
<ul>
	<li>Go Testing</li>
	<li>Minimal Scalable Units</li>
	<li>Go Benchmarks</li>
	<li><a href="https://godoc.org/golang.org/x/perf/cmd/benchstat">benchstat</a></li>
	<li><code>benchmem</code></li>
	<li><code>blockprofile</code></li>
</ul>
</p>

<p>Now instead wondering why your concurrent performance is slower, you have some tools to figure why things got slower and some ideas on how to fix it. Instead of the broken slow implementation we started with, we now have a correct, fast implementation:</p>

{{benchstat "serial.txt reduce-allocs.txt"}}