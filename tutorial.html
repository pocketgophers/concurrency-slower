<h1>Balancing Concurrent Overhead With Parallel Performance</h1>

{{removeAll .SiteDir}}
{{mkdirAll .SiteDir}}
{{removeAll .BuildDir}}
{{mkdirAll .BuildDir}}
{{cd .BuildDir}}
{{runNoOutput "git" "init"}}

<blockquote>
<p>WTH? Shouldnâ€™t this be faster? - <a href="https://forum.golangbridge.org/t/concurrency-slower/5002" title="Concurrency slower?">Concurrency slower?</a></p>
</blockquote>

<p>This started as a simple exercise to learn concurrency in Go. The exercise had a simple premise:
	<ul>
		<li>create a list of 1,000,000 lotto numbers</li>
		<li>a lotto number is a list of 7 random integers</li>
	</ul>
</p>

<p>But instead of fast running goodness, it ended slower than it started:
	<blockquote>
	<ul>
		<li>Initially on my system it took 8.5 s (i7)</li>
		<li>Giving the channel such a large buffer reduces the used time to ~4.5 s</li>
		<li><code>make</code>ing the array list with the final size increases the used time by ~20%</li>
		<li>Running as a go routine increases the used time to ~13 s - WTH? Shouldn&#39;t this be faster?</li>
	</ul>
	</blockquote>
</p>

<p>Go's concurrency primitives are light-weight. However, they are not free. Since there is a cost, there needs to be a return on that investment. For this exercise, the expected return is a faster runtime. Balancing the costs and the benefits is the real trick.</p>

<!-- <p>Follow along as I show one method, and the tools used, to balance the execution costs of concurrency with the benefits of reduced runtime through a parallel implementation.</p> -->

<!-- <p>NOTE: The process I describe is not the actual process I followed. It does the describe all the failed attempts I actually made. That would be extremely tedious to read (and even more so to write). However, the process shown <em>does</em> include the methods that indicate the step was productive</p> -->

<h2>The Posted Code</h2>
{{apply "original"}}
{{commit "original"}}

<p>Let's start with what was posted:</p>

{{file "main.go"}}

<p>This code has some good things going for it:
	<ul>
		<li>Easy to try out improvements because timing checks are built in.</li>
		<li>Visual test, <code>len(list)</code>, indicates if the program worked or not</li>
	</ul>
</p>

<p>However, it also has some problems as can be shown by running it:</p>

{{run "go" "run" "main.go"}}

<p>Notice that <code>len(list)</code> is not the expected 1,000,000. <a href="https://forum.golangbridge.org/t/concurrency-slower/5002/3?u=nathankerr">Another posted version</a> had the right <code>len(list)</code>, but only one of the elements was set (1M times).</p>

<p>Let's use Go's built-in testing and benchmarking tools to improve the code.</p>

<h2>Extract to Function</h2>
{{apply "extract-function"}}
{{commit "extract function"}}

<p>The first step is to isolate the code to be tested and benchmarked.</p>

<ul>
	<li>extract to function</li>
	<li>remove globals</li>
	<li>remove magic numbers</li>
</ul>

{{file "main.go"}}

<p><code>numberToGenerate</code> is a global constant because I want to make sure all instances of that number are the same, and it is the only parameter of this program to tweak.</p>

<h2>Testing with <code>go test</code></h2>
{{apply "testing"}}
{{commit "testing"}}

<p>Testing results based on random numbers is really hard. The test suite for <a href="https://golang.org/pkg/math/rand"><code>math/rand</code></a> includes a statistical analysis of the generated numbers.</p>

<p>In this case, testing will be done from two directions:
	<ol>
		<li>the correct number of lotto numbers was generated</li>
		<li>the generated numbers have a <a href="https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29">uniform distribution</a>, just like the RNG.</li>
	</ol>
</p>

<p>Since this testing is done as an exercise, and I don't really know what the properties of lottery numbers should be, I picked a few attributes of distributions to compare against expected values:
<ul>
	<li><a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Skewness">Skewness</a></li>
	<li><a href="https://en.wikipedia.org/wiki/Excess_kurtosis">Ex. kurtosis</a></li>
</ul>

{{file "main_test.go"}}

{{run "go" "test"}}

<p>Here we see that the some parts of the test failed. The parts that fail will change between runs because <code>lottoNumbers</code> does not produce consistent results.</p>

<h1>A Serial Version</h1>
{{apply "serial"}}
{{commit "serial"}}

<p>Before getting to benchmarking, let's get a version that consistently passes the tests. Since the concurrency used here complicates the design instead of simplifying it, a purely serial version that is correct is a better starting point. I tried to reproduce the serial version the poster started with.</p>

{{file "main.go"}}

{{run "go" "run" "main.go"}}

{{run "go" "test"}}

<p>This version is much faster. The speedup was achieved by not doing the extra work the original version did. Also, the tests pass.</p>

<h2>Benchmarks</h2>
{{apply "benchmark"}}

<p>Go benchmarks are quick to get started with: loop `b.N` times, calling the function to be benchmarked each iteration.</p>

{{file "main_test.go"}}

<p>Benchmarks are ran with <code>go test</code>.</p>

{{run "go test -bench=. -benchmem -count 5 | tee serial.txt"}}

<p>The output shows the benchmark, the number of times the benchmark loop ran (i.e., <code>b.N</code>), and the average time for each run (i.e., total_time/b.N)</p>

<p>NOTE: go will run the entire test suite before running the benchmarks. This is helpful to ensure the whatever you are benchmarking still passes the tests.</p>

{{commit "benchmark"}}

<h2>Parallel</h2>
{{apply "parallel"}}

{{file "main.go"}}

{{run "go test -bench=. -count 5 | tee parallel.txt"}}

{{benchstat "serial.txt parallel.txt"}}

{{commit "parallel"}}

<h2>Finding Blocking Operations</h2>

{{run "go test -blockprofile block.pprof"}}
{{run "go tool pprof -list=lottoNumbers ./concurrency-slower.test block.pprof"}}

{{commit "blocking-operations"}}

<h2>Non-Blocking Rand</h2>
{{apply "non-blocking-rand"}}

{{file "main.go"}}

{{run "go test -bench=. -count 5 | tee non-blocking-rand.txt"}}

{{benchstat "serial.txt non-blocking-rand.txt"}}

{{commit "non-blocking-rand"}}

<h2>Reducing allocations</h2>

{{run "go test -bench=. -count 5 -benchmem| tee non-blocking-rand-mem.txt"}}

{{apply "reduce-allocs"}}

{{run "go test -bench=. -count 5 -benchmem| tee reduce-allocs.txt"}}

{{benchstat "non-blocking-rand-mem.txt reduce-allocs.txt"}}

{{commit "reduce allocs"}}

<h2>Success</h2>

{{benchstat "serial.txt reduce-allocs.txt"}}

<hr>
<pre>TODO
- msu
- figure out how to sanitize pprof output
- file should only display the file, diffs are hard to format and I want to avoid that for now. Also the automatic switching won't let me show the whole thing when the diff is complicated.

published repo:
- source branch for tutorial source
- 2017-04-2x branch for released version
- set dated branch as default branch
- readme in all branches explaining the organization

share:
- I used go's testing, benchmarking, and blockprofile tools to show an alternate way to make the same progress. link
</pre>
